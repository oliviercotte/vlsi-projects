----------------------------------------------------------------------------------------------------
-- TITLE:         RAM
-- DESCRIPTION:   RAM with test program for 8-bit stack-based processor.
-- GENERATED BY:  assembler.tcl with 'recurse.asm' as input
----------------------------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.opcodes.all;

architecture recurse of ram is
	type mem_t  is array(integer range <>) of std_logic_vector(7 downto 0);

	constant USEFUL_BITS: natural := 12;
	constant ZERO: std_logic_vector(16-USEFUL_BITS-1 downto 0) := (others=>'0');
	constant WORDS: natural := 142;

	signal   for_me:  std_logic;
	signal   mem:     mem_t(0 to 2**USEFUL_BITS - 1);

	constant program: mem_t(0 to WORDS - 1) := (
		OP_CONST_W, -- 0x0000
		STD_LOGIC_VECTOR( TO_UNSIGNED(0, 8) ),
		STD_LOGIC_VECTOR( TO_UNSIGNED(4, 8) ),
		OP_W_TO_SP, -- 0x0003
		OP_CONST_W, -- 0x0004
		STD_LOGIC_VECTOR( TO_UNSIGNED(0, 8) ),
		STD_LOGIC_VECTOR( TO_UNSIGNED(4, 8) ),
		OP_W_TO_BP, -- 0x0007
		OP_CONST, -- 0x0008
		STD_LOGIC_VECTOR( TO_SIGNED(15, 8) ),
		OP_PUT, -- 0x000a
		STD_LOGIC_VECTOR( TO_SIGNED(1, 8) ),
		OP_PC_TO_W, -- 0x000c
		OP_CONST, -- 0x000d
		STD_LOGIC_VECTOR( TO_SIGNED(14, 8) ),
		OP_ADD_W, -- 0x000f
		OP_PUSH_WH, -- 0x0010
		OP_PUSH_WL, -- 0x0011
		OP_BP_TO_W, -- 0x0012
		OP_PUSH_WH, -- 0x0013
		OP_PUSH_WL, -- 0x0014
		OP_CONST, -- 0x0015
		STD_LOGIC_VECTOR( TO_SIGNED(2, 8) ),
		OP_ADD_W, -- 0x0017
		OP_W_TO_BP, -- 0x0018
		OP_JMP, -- 0x0019
		STD_LOGIC_VECTOR( TO_SIGNED(6, 8) ),
		OP_GET, -- 0x001b
		STD_LOGIC_VECTOR( TO_SIGNED(0, 8) ),
		OP_GET, -- 0x001d
		STD_LOGIC_VECTOR( TO_SIGNED(1, 8) ),
		OP_JMP, -- 0x001f
		STD_LOGIC_VECTOR( TO_SIGNED(-2, 8) ),
		OP_GET, -- 0x0021
		STD_LOGIC_VECTOR( TO_SIGNED(-1, 8) ),
		OP_CONST, -- 0x0023
		STD_LOGIC_VECTOR( TO_SIGNED(0, 8) ),
		OP_CMP, -- 0x0025
		OP_BNE, -- 0x0026
		STD_LOGIC_VECTOR( TO_SIGNED(10, 8) ),
		OP_CONST, -- 0x0028
		STD_LOGIC_VECTOR( TO_SIGNED(0, 8) ),
		OP_CONST, -- 0x002a
		STD_LOGIC_VECTOR( TO_SIGNED(0, 8) ),
		OP_PUT, -- 0x002c
		STD_LOGIC_VECTOR( TO_SIGNED(-1, 8) ),
		OP_PUT, -- 0x002e
		STD_LOGIC_VECTOR( TO_SIGNED(-2, 8) ),
		OP_JMP, -- 0x0030
		STD_LOGIC_VECTOR( TO_SIGNED(82, 8) ),
		OP_GET, -- 0x0032
		STD_LOGIC_VECTOR( TO_SIGNED(-1, 8) ),
		OP_CONST, -- 0x0034
		STD_LOGIC_VECTOR( TO_SIGNED(1, 8) ),
		OP_CMP, -- 0x0036
		OP_BNE, -- 0x0037
		STD_LOGIC_VECTOR( TO_SIGNED(10, 8) ),
		OP_CONST, -- 0x0039
		STD_LOGIC_VECTOR( TO_SIGNED(0, 8) ),
		OP_CONST, -- 0x003b
		STD_LOGIC_VECTOR( TO_SIGNED(1, 8) ),
		OP_PUT, -- 0x003d
		STD_LOGIC_VECTOR( TO_SIGNED(-1, 8) ),
		OP_PUT, -- 0x003f
		STD_LOGIC_VECTOR( TO_SIGNED(-2, 8) ),
		OP_JMP, -- 0x0041
		STD_LOGIC_VECTOR( TO_SIGNED(65, 8) ),
		OP_CONST, -- 0x0043
		STD_LOGIC_VECTOR( TO_SIGNED(1, 8) ),
		OP_GET, -- 0x0045
		STD_LOGIC_VECTOR( TO_SIGNED(-1, 8) ),
		OP_SUB, -- 0x0047
		OP_PUT, -- 0x0048
		STD_LOGIC_VECTOR( TO_SIGNED(1, 8) ),
		OP_PC_TO_W, -- 0x004a
		OP_CONST, -- 0x004b
		STD_LOGIC_VECTOR( TO_SIGNED(14, 8) ),
		OP_ADD_W, -- 0x004d
		OP_PUSH_WH, -- 0x004e
		OP_PUSH_WL, -- 0x004f
		OP_BP_TO_W, -- 0x0050
		OP_PUSH_WH, -- 0x0051
		OP_PUSH_WL, -- 0x0052
		OP_CONST, -- 0x0053
		STD_LOGIC_VECTOR( TO_SIGNED(2, 8) ),
		OP_ADD_W, -- 0x0055
		OP_W_TO_BP, -- 0x0056
		OP_JMP, -- 0x0057
		STD_LOGIC_VECTOR( TO_SIGNED(-56, 8) ),
		OP_CONST, -- 0x0059
		STD_LOGIC_VECTOR( TO_SIGNED(2, 8) ),
		OP_GET, -- 0x005b
		STD_LOGIC_VECTOR( TO_SIGNED(-1, 8) ),
		OP_SUB, -- 0x005d
		OP_PUT, -- 0x005e
		STD_LOGIC_VECTOR( TO_SIGNED(3, 8) ),
		OP_PC_TO_W, -- 0x0060
		OP_CONST, -- 0x0061
		STD_LOGIC_VECTOR( TO_SIGNED(14, 8) ),
		OP_ADD_W, -- 0x0063
		OP_PUSH_WH, -- 0x0064
		OP_PUSH_WL, -- 0x0065
		OP_BP_TO_W, -- 0x0066
		OP_PUSH_WH, -- 0x0067
		OP_PUSH_WL, -- 0x0068
		OP_CONST, -- 0x0069
		STD_LOGIC_VECTOR( TO_SIGNED(4, 8) ),
		OP_ADD_W, -- 0x006b
		OP_W_TO_BP, -- 0x006c
		OP_JMP, -- 0x006d
		STD_LOGIC_VECTOR( TO_SIGNED(-78, 8) ),
		OP_GET, -- 0x006f
		STD_LOGIC_VECTOR( TO_SIGNED(0, 8) ),
		OP_GET, -- 0x0071
		STD_LOGIC_VECTOR( TO_SIGNED(2, 8) ),
		OP_GET, -- 0x0073
		STD_LOGIC_VECTOR( TO_SIGNED(3, 8) ),
		OP_GET, -- 0x0075
		STD_LOGIC_VECTOR( TO_SIGNED(1, 8) ),
		OP_ADD, -- 0x0077
		OP_PUT, -- 0x0078
		STD_LOGIC_VECTOR( TO_SIGNED(-1, 8) ),
		OP_BC, -- 0x007a
		STD_LOGIC_VECTOR( TO_SIGNED(2, 8) ),
		OP_JMP, -- 0x007c
		STD_LOGIC_VECTOR( TO_SIGNED(3, 8) ),
		OP_CONST, -- 0x007e
		STD_LOGIC_VECTOR( TO_SIGNED(1, 8) ),
		OP_ADD, -- 0x0080
		OP_ADD, -- 0x0081
		OP_PUT, -- 0x0082
		STD_LOGIC_VECTOR( TO_SIGNED(-2, 8) ),
		OP_POP_WL, -- 0x0084
		OP_POP_WH, -- 0x0085
		OP_W_TO_BP, -- 0x0086
		OP_POP_WL, -- 0x0087
		OP_POP_WH, -- 0x0088
		OP_W_TO_PC, -- 0x0089
		OP_NOP, OP_NOP,
		OP_JMP,
		STD_LOGIC_VECTOR( TO_SIGNED(0, 8) ) );

begin

	for_me <= '1' when in_addr(15 downto USEFUL_BITS) = ZERO else '0';

	process(clk, rst_n)
		variable uidx: unsigned(USEFUL_BITS-1 downto 0);
	begin
		if rst_n = '0' then
			for idx in 0 to WORDS - 1 loop
				mem(idx)   <= program(idx);
			end loop;
			for idx in WORDS to mem'HIGH loop
				mem(idx) <= x"ff";
			end loop;
		elsif clk'event and clk = '1' then
			if in_wr = '1' and for_me = '1' then
				uidx := UNSIGNED( in_addr(USEFUL_BITS-1 downto 0) );
				mem( TO_INTEGER(  uidx ) ) <= io_data;
			end if;
		end if;
	end process;

	process(in_addr, mem, for_me, in_rd)
		variable uidx: unsigned(USEFUL_BITS-1 downto 0);
	begin
		if in_rd = '1' and for_me = '1' then
			uidx := UNSIGNED( in_addr(USEFUL_BITS-1 downto 0) );
			io_data <= mem( TO_INTEGER(  uidx  ) );
		else
			io_data <= (others => 'Z');
		end if;
	end process;
end recurse;
